package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"context"
	"cortei-server/internal/domain"
	apperrors "cortei-server/internal/errors"
	"cortei-server/internal/validation"
	"errors"
	"fmt"
	"strings"
	"time"

	"github.com/vektah/gqlparser/v2/gqlerror"
)

// O gqlgen vai gerar a função CreateAppointment em `generated.go` e a implementa aqui.
func (r *mutationResolver) CreateAppointment(ctx context.Context, input domain.NewAppointment) (*domain.Appointment, error) {
	if err := validation.ValidateNewAppointmentInput(input); err != nil {
		return nil, err
	}

	newApp := &domain.Appointment{
		ClientName: input.ClientName,
		Date:       input.Date,
		Time:       input.Time,
	}

	// Call repository layer to save data
	createdApp, err := r.Repo.Create(ctx, newApp)
	if err != nil {
		return nil, err
	}

	return createdApp, nil
}

// DeleteAppointment is the resolver for the deleteAppointment field.
func (r *mutationResolver) DeleteAppointment(ctx context.Context, id string) (bool, error) {
	uid, err := domain.ParseAppointmentID(strings.TrimSpace(id))
	if err != nil {
		return false, &apperrors.ValidationError{Field: "id", Message: "must be a valid UUID"}
	}
	if err := r.Repo.Delete(ctx, uid); err != nil {
		var nf *gqlerror.Error
		if errors.As(err, &nf) {
			return false, nf
		}
		return false, fmt.Errorf("failed to delete appointment: %w", err)
	}
	return true, nil
}

// Appointments is the resolver for the appointments field.
func (r *queryResolver) Appointments(ctx context.Context) ([]*domain.Appointment, error) {
	return r.Repo.List(ctx)
}

// AppointmentsByDay is the resolver for the appointmentsByDay field.
func (r *queryResolver) AppointmentsByDay(ctx context.Context, date string) (*domain.DailyAppointments, error) {
	if strings.TrimSpace(date) == "" {
		return nil, &apperrors.ValidationError{Field: "date", Message: "cannot be empty"}
	}

	appointments, err := r.Repo.GetByDay(ctx, date)
	if err != nil {
		return nil, fmt.Errorf("failed to get appointments for date %s: %w", date, err)
	}

	appointmentValues := make([]domain.Appointment, len(appointments))
	for i, app := range appointments {
		appointmentValues[i] = *app
	}

	dailyAppointments := domain.GroupAppointmentsByDay(date, appointmentValues)

	return &dailyAppointments, nil
}

// AvailableTimesByDay is the resolver for the availableTimesByDay field.
func (r *queryResolver) AvailableTimesByDay(ctx context.Context, date string) (*domain.AvailableTimes, error) {
	trimmedDate := strings.TrimSpace(date)
	if trimmedDate == "" {
		return nil, &apperrors.ValidationError{Field: "date", Message: "cannot be empty"}
	}

	if _, err := time.Parse("2006-01-02", trimmedDate); err != nil {
		return nil, &apperrors.ValidationError{Field: "date", Message: "must be in YYYY-MM-DD format"}
	}

	appointments, err := r.Repo.GetByDay(ctx, trimmedDate)
	if err != nil {
		return nil, fmt.Errorf("failed to get appointments for date %s: %w", trimmedDate, err)
	}

	appointmentValues := make([]domain.Appointment, len(appointments))
	for i, app := range appointments {
		appointmentValues[i] = *app
	}

	availableTimes := domain.CalculateAvailableTimes(trimmedDate, appointmentValues)
	return &availableTimes, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
