package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"context"
	"cortei-server/internal/domain"
	apperrors "cortei-server/internal/errors"
	"cortei-server/internal/validation"
	"errors"
	"fmt"
	"log/slog"
	"strings"
	"time"

	"github.com/vektah/gqlparser/v2/gqlerror"
)

// O gqlgen vai gerar a função CreateAppointment em `generated.go` e a implementa aqui.
func (r *mutationResolver) CreateAppointment(ctx context.Context, input domain.NewAppointment) (*domain.Appointment, error) {
	if err := validation.ValidateNewAppointmentInput(input); err != nil {
		return nil, err
	}

	newApp := &domain.Appointment{
		ClientName: input.ClientName,
		Date:       input.Date,
		Time:       input.Time,
	}

	// Call repository layer to save data
	createdApp, err := r.Repo.Create(ctx, newApp)
	if err != nil {
		return nil, err
	}

	return createdApp, nil
}

// DeleteAppointment is the resolver for the deleteAppointment field.
func (r *mutationResolver) DeleteAppointment(ctx context.Context, id string) (bool, error) {
	uid, err := domain.ParseAppointmentID(strings.TrimSpace(id))
	if err != nil {
		return false, &apperrors.ValidationError{Field: "id", Message: "must be a valid UUID"}
	}
	if err := r.Repo.Delete(ctx, uid); err != nil {
		var nf *gqlerror.Error
		if errors.As(err, &nf) {
			return false, nf
		}
		return false, fmt.Errorf("failed to delete appointment: %w", err)
	}
	return true, nil
}

// Appointments is the resolver for the appointments field.
func (r *queryResolver) Appointments(ctx context.Context) ([]*domain.Appointment, error) {
	return r.Repo.List(ctx)
}

// AppointmentsByDay is the resolver for the appointmentsByDay field.
func (r *queryResolver) AppointmentsByDay(ctx context.Context, date string) (*domain.DailyAppointments, error) {
	normalizedDate, err := normalizeDate(date)
	if err != nil {
		return nil, err
	}

	appointments, err := r.Repo.GetByDay(ctx, normalizedDate)
	if err != nil {
		return nil, fmt.Errorf("failed to get appointments for date %s: %w", normalizedDate, err)
	}

	appointmentValues := toAppointmentValues(appointments)

	dailyAppointments, invalid := domain.GroupAppointmentsByDay(normalizedDate, appointmentValues)
	logInvalidPeriodEntries("AppointmentsByDay", normalizedDate, invalid)

	return &dailyAppointments, nil
}

// AvailableTimesByDay is the resolver for the availableTimesByDay field.
func (r *queryResolver) AvailableTimesByDay(ctx context.Context, date string) (*domain.AvailableTimes, error) {
	normalizedDate, err := normalizeDate(date)
	if err != nil {
		return nil, err
	}

	appointments, err := r.Repo.GetByDay(ctx, normalizedDate)
	if err != nil {
		return nil, fmt.Errorf("failed to get appointments for date %s: %w", normalizedDate, err)
	}

	appointmentValues := toAppointmentValues(appointments)

	availableTimes, invalid := domain.GroupAvailableTimesByDay(normalizedDate, appointmentValues)
	logInvalidPeriodEntries("AvailableTimesByDay", normalizedDate, invalid)
	return &availableTimes, nil
}

func normalizeDate(date string) (string, error) {
	trimmed := strings.TrimSpace(date)
	if trimmed == "" {
		return "", &apperrors.ValidationError{Field: "date", Message: "cannot be empty"}
	}

	if _, err := time.Parse("2006-01-02", trimmed); err != nil {
		return "", &apperrors.ValidationError{Field: "date", Message: "must be in YYYY-MM-DD format"}
	}

	return trimmed, nil
}

func toAppointmentValues(appointments []*domain.Appointment) []domain.Appointment {
	values := make([]domain.Appointment, 0, len(appointments))
	for _, app := range appointments {
		if app == nil {
			continue
		}
		values = append(values, *app)
	}
	return values
}

func logInvalidPeriodEntries(operation, date string, invalid []domain.InvalidPeriodEntry) {
	if len(invalid) == 0 {
		return
	}

	for _, entry := range invalid {
		slog.Warn("Skipping entry outside scheduling periods",
			"operation", operation,
			"date", date,
			"time", entry.Time,
			"source", entry.Source,
			"reason", entry.Reason,
		)
	}
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
